version: 2.1

executors:
  base:
    docker:
      - image: cimg/base:stable
    working_directory: ~/project

commands:
  install-tools:
    steps:
      - run:
          name: Install Terraform and gcloud
          command: |
            # Install Terraform via zip 
            TERRAFORM_VERSION=1.12.2
            curl -fsSL "https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip" -o terraform.zip
            unzip -o terraform.zip -d tf-bin
            sudo mv tf-bin/terraform /usr/local/bin/
            terraform version

            # Install gcloud
            export CLOUDSDK_CORE_DISABLE_PROMPTS=1
            export CLOUDSDK_INSTALL_DIR=$HOME
            curl -sSL https://sdk.cloud.google.com | bash
            source "$HOME/google-cloud-sdk/path.bash.inc"
            echo 'source "$HOME/google-cloud-sdk/path.bash.inc"' >> $BASH_ENV
            gcloud version

jobs:
  provision-db:
    executor: base
    environment:
      TF_VAR_db_pass: postgres123
    steps:
      - checkout
      - install-tools
      - run:
          name: Authenticate GCP
          command: |
            echo "$GCLOUD_SERVICE_KEY" > creds.json
            gcloud auth activate-service-account --key-file=creds.json
            gcloud config set project "$GCP_PROJECT_ID"

      - run:
          name: Sanitize branch name
          command: |
            export SANITIZED_BRANCH=$(echo "$CIRCLE_BRANCH" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
            echo "export SANITIZED_BRANCH=$SANITIZED_BRANCH" >> $BASH_ENV

      - run:
          name: Check if DB instance exists & optionally skip Terraform apply
          command: |
            source $BASH_ENV
            INSTANCE_NAME="sql-${SANITIZED_BRANCH}"
            if gcloud sql instances describe "$INSTANCE_NAME" > /dev/null 2>&1; then
              echo "Cloud SQL instance '$INSTANCE_NAME' already exists. Skipping terraform apply."
            else
              cd terraform
              terraform init
              terraform apply -auto-approve \
                -var="project_id=$GCP_PROJECT_ID" \
                -var="instance_name=$INSTANCE_NAME" \
                -var="db_pass=$TF_VAR_db_pass" \
                -var="gcp_credentials_json=$GCLOUD_SERVICE_KEY"
            fi

  run-migrations:
    executor: base
    environment:
      DB_PORT: 5432
    steps:
      - checkout
      - install-tools
      - run:
          name: Install golang-migrate CLI
          command: |
            curl -L https://github.com/golang-migrate/migrate/releases/download/v4.17.0/migrate.linux-amd64.tar.gz -o migrate.tar.gz
            tar -xzf migrate.tar.gz
            sudo mv migrate /usr/local/bin/migrate
            migrate -version
      - run:
          name: Extract Terraform Outputs
          command: |
            cd terraform
            terraform init -input=false
            terraform output -raw db_public_ip > ../DB_HOST
            terraform output -raw db_user > ../DB_USER
            terraform output -raw db_name > ../DB_NAME
      - run:
          name: Run DB Migrations
          command: |
            DB_HOST=$(cat DB_HOST)
            DB_USER=$(cat DB_USER)
            DB_NAME=$(cat DB_NAME)
            migrate -path db/migrations -database "postgres://${DB_USER}:${TF_VAR_db_pass}@${DB_HOST}:${DB_PORT}/${DB_NAME}?sslmode=disable" up

  test-go-api:
    docker:
      - image: cimg/go:1.24
    environment:
      DB_PORT: 5432
    steps:
      - checkout
      - run:
          name: Extract DB info from Terraform outputs
          command: |
            cd terraform
            terraform init
            terraform output -raw db_public_ip > ../DB_HOST
            terraform output -raw db_user > ../DB_USER
            terraform output -raw db_name > ../DB_NAME
      - run:
          name: Run and Test Go API
          command: |
            DB_HOST=$(cat DB_HOST)
            DB_USER=$(cat DB_USER)
            DB_NAME=$(cat DB_NAME)

            export DB_HOST=$DB_HOST
            export DB_USER=$DB_USER
            export DB_NAME=$DB_NAME
            export DB_PASS=$TF_VAR_db_pass
            export DB_PORT=5432
            export PORT=8080

            echo "Starting Go API in background..."
            go run main.go &
            APP_PID=$!

            echo "Waiting for API to boot..."
            sleep 5

            echo "Testing /health endpoint..."
            curl --fail http://localhost:8080/health

            echo "Killing Go API"
            kill $APP_PID

  destroy-db:
    executor: base
    steps:
      - checkout
      - install-tools
      - run:
          name: Authenticate GCP
          command: |
            echo "$GCLOUD_SERVICE_KEY" > creds.json
            gcloud auth activate-service-account --key-file=creds.json
            gcloud config set project "$GCP_PROJECT_ID"

      - run:
          name: Sanitize branch name
          command: |
            export SANITIZED_BRANCH=$(echo "$CIRCLE_BRANCH" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
            echo "export SANITIZED_BRANCH=$SANITIZED_BRANCH" >> $BASH_ENV

      - run:
          name: Destroy Terraform Resources
          command: |
            source $BASH_ENV
            cd terraform
            terraform init
            terraform destroy -auto-approve \
              -var="project_id=$GCP_PROJECT_ID" \
              -var="instance_name=sql-${SANITIZED_BRANCH}" \
              -var="db_pass=$TF_VAR_db_pass"

workflows:
  version: 2
  cloudsql-dev:
    jobs:
      - provision-db:
          filters:
            branches:
              only: /^feature\/.*/

      - run-migrations:
          requires:
            - provision-db

      - test-go-api:
          requires:
            - run-migrations

      - destroy-db:
          filters:
            branches:
              only: main
          requires:
            - provision-db
